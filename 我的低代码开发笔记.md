


# 项目搭建

  - eslint自动修复：VScode安装插件+ VScode配置json

      VScode配置：
      "editor.codeActionsOnSave": {
              "source.fixAll": "always"
          }

  - 项目中有共用的html头部或者尾部，可选的方案：

      1.采用嵌套路由，父路由带着头尾布局，需要公用的页面作为子路由。
      2.采用meta元信息，添加标志决定是否要首尾。在APP.vue中动态选择。

  - vite 搭建项目在开发阶段之所以比 vue-cli快，是因为：

    Webpack中:将源码转为兼容浏览器的js代码，只有几个文件

    而Rollup：将源码转为相对应的es modules模块化文件，省去处理兼容问题

      -Vite的缺点
          测试阶段，还未一体化
          只支持新版支持ESmodules的浏览器
          第三方库也需要都支持ESmodules
          CommonjS支持有限
          开发构建属于两套系统,可能导致生产和开发的不一致行为


# 快捷键

    快捷键来一次性折叠或展开所有代码块：

    折叠所有：Ctrl + K, Ctrl + 0
    展开所有：Ctrl + K, Ctrl + J

# vue

    - Vue 2 中，通常使用 createElement 函数来创建虚拟 DOM 节点，而在 Vue 3 中，它被重命名为 h。作用是根据传入的参数创建一个虚拟 DOM 节点（VNode）。

            import { h } from 'vue';
            const vnode = h('tag', props, children);  // const vnode = h('tag');
            或const vnode = h('div', { class: 'container' }, 'Hello, World!');


            参数说明：
           第一个参数是一个字符串，表示要创建的元素的标签名。
            第二个参数是一个对象，包含了要设置的元素属性，例如类名、样式等。
            第三个参数是一个字符串或者数组，表示子节点的内容。可以是文本内容，也可以是其他的 VNode。


    -下拉框选择，需要自定义每个下拉项的样式时：
        1.直接写在html标签结构，不通过变量有效
        2.通过变量，但是使用v-html也有效。
        3.通过变量直接插入，再回显的html结果，会将自定义的html结构标签显示为字符串。

          场景需求：不使用v-html与直接写明dom结构时，即需要js灵活渲染html结构。

          -vue/js文件创建vue组件，利用render配置函数或者setup返回h函数的执行，作为中转渲染变量（也类似v-html）
          （待确定）

          -jsx/tsx文件方法：对应传入变量也使用Vnode类型，tsx模版可以直接渲染


      Vue 2.x 默认不支持 JSX 或 TSX 语法。 然而，从 Vue 3.0 开始，Vue 提供了对 JSX 的原生支持，也对 TypeScript 有更好的支持，因此你可以使用 TSX 语法编写类型安全的 Vue 组件。




# js

    -截取指定的字符串，如获取文件名：

      const reg = /.*\/(.*)\.vue/;
      reg.exec(xxxx); //返回一个数组，第一个原字符串，第二个是匹配到的内容，可以多个。


# ts

    -js中，需要获取普通对象的所有key，组成一个新的声明类型
      let componentList = {...}
      type keys = keyof typeof componentList;

    -ts中，需要获取ts声明的对象类型的所有key，来组成新的声明类型
      type keys = typeof ts声明的对象类型;

    -ts限制对象的key的选值，使用in，不使用':' :
      export type PropsTableMap = {
          [propName in keyof AllWidgetProps]?: PropsToForm // 注意该写法，不加问号表示应出现所有key
      }



# webpack

  -require.context

    // 创建一个模块上下文，搜索当前目录下的所有以.vue结尾的文件
    三个参数：
      要搜索的文件夹路径；
      是否搜索其子目录；
      一个正则表达式，用于匹配文件名。

    注意：在项目中，require.context函数的参数是一个静态的字符串，无法使用函数动态传递，这是因为webpack在编译时需要根据这个参数来确定需要打包的模块。

  -Webpack 默认的占位符包括以下几种：

    [name]: 文件的名称，不包括后缀。
    [path]: 文件相对于项目根目录的路径，包括文件名。
    [base]: 文件的基础名称，即文件名加后缀，不包括路径。
    [ext]: 文件的后缀名。
    [folder]: 文件所在的文件夹名称。
    [query]: 文件的查询参数部分。




开发任务：

  - 国际化
  - 漫游式导航

  - 项目搭建：框架引入、工具使用（完成）
  - 首页框架布局、路由编写（完成）
  - 基本样式及分区（完成）
  - UI库按需引入（完成）、图片全局 按需引入（完成）、重置UI库样式（完成）
  - eslint空格检测与格式化代码的不同标准的问题（完成）
  - svg图标的引入
  - vuex仓库（完成）
  - 路由拦截器
  - 全局请求方法


  - 首页基础排版（完成）
  - 自动引入全局组件（完成）
  - 问卷头部排版样式（完成）、左分区（完成）、右分区（完成）、中间分区（完成）
  - 区域编写规则分析：

    【
        1.左侧（即物料）：拖拽使用插件。渲染方式为生成的json文件，包含多个物料的初始数据及属性描述
        2.中间：拖拽组件循环数据源，渲染组件列表；每个组件props接收，右侧的json集合
        3.右侧：右侧的内容都为中间的单个组件服务（即物料属性面板）;渲染方式为遍历选中的物料属性列表。
        4.哪些需要组件与json结构分离：右侧物料属性列表的每一项、中间实例化的物料

        注意点：
        1.分两个项目，与iframe交互，跨 Iframe 通信，需要假的Iframe？好处是用户在使用预览页面时，不用加载低代码平台的代码。Iframe约等于沙箱，可以与主应用隔离。
        2.需注意应支持组件嵌套


        开发：
        0.物料json可视化生成、物料呈现的样子自己编写
        1.物料json编写与渲染：
        物料json、物料组件怎么写：相当于组件结构与数据结构分离->结构vue文件自己写、结构写在TS限制下的js导出对象，该对象负责左侧物料、右侧物料属性的渲染基础、以及物料实例化后的样式。
        物料json获取：通过获取文件夹下的每个json，集合成一个大json，key为组件名。
        物料json写完如何渲染：分为两个大对象，一个schema负责左边，遍历对象渲染物料。一个fields负责右边，判断当前选中的是那个实例化物料，再决定渲染右边对象的具体哪个。
        2.中间大组件如何接收物料、并实例化、遍历渲染：遍历、添加和移除仓库存储的数组
    】



- 标准规范

  1.建立编辑器仓库：存储当前编辑器预览的组件列表、选中的组件

  2.物料数据结构、初始值的定义

  3.仓库中测试实例化的物料，在面板中的展示 -> 物料按照既定的默认属性显示 -> 值 样式(过滤多余的样式属性)

  4.左侧的组件区渲染：数据源问题(需解决：默认props、映射组件名name、icon、title、嵌套的label)、图标问题（库图标与svg可以在公共组件实现兼容）

    -包裹wrapper，点击添加id，push组件数组

  5.右侧属性表单：

    -制定映射结构 -> 显示每个表单项+哪些属性不映射表单项(以props表单的模版为主，没有对应的key不渲染即可)

    -复杂表单项：即不是单层标签的结构，建议二次封装

    -表单props实时更新： 

      -表单需初始化时能回显默认值
      -表单值修改时应该将模版的数据改为响应式（可选）
      -表单的更改能通知仓库，当前选中的组件属性变化

      -不同属性值，在同一表单项的格式问题
      -透明度属性
      -空文本时占位
      -下拉样式


  6.顶部工具栏：
  
    -删除物料



上传图片、轮播、问卷选项
复制组件
